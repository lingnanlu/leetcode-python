'''
形象的想象一下, 如果是你, 你怎么做?
直觉告诉自己, 肯定是有两种不同的就先装两种不同的
这里的关键是, 如何形式化的表达出以上思想.

假如有两种杯子, a, b

那么, 一定是 min(a, b) + max(a, b) - min(a, b) = max(a, b)

举几个例子

1, 1 = 1
1, 2 = 2
3, 2 = 3


那么, 三种呢? 
如果我们能从2种推导出3种, 那么, 说不定可以从3种推导出4种, 这样, 不管有几种, 我们就有一种通用的方法了.

最简单的, 假如不考虑顺序.

怎么能利用两种, 有两种方法
1. 利用前两种的方法
2. 利用前两种的结果

这里好像利用不了结果, 试试方法.

比如, 先只考虑前两种, 还有剩余, 再将剩余的与第3种做为前两咱的.

1. min (a, b)
2. max (a, b) - min(a, b) : 剩余的, 又和c组成两咱.
3. max (max (a, b) - min(a, b), c)  

现在似乎给出公式, 但这样对么?

比如说, [1, 1, 2]
按照公式是 1 + 2 = 3
但其实可以做到 2次.

那么, 说明以上公式是不对的,

而为什么能做到两次呢? 这里面的规律是什么?
我直观的一种感觉就是, 每一次先择两个, 并尽可能让剩余的也能两两组合. 也就是, 每一次的选择, 尽量不让杯子的种类数减少.

那么每次选择哪两个呢?
既然和顺序无关, 我们先从小到大排个序.
这里可以试试, 先选择特殊的两个, 比如两个最小, 两个最大, 最小和最大.

分别考虑一下

两个最小: 这可能会让杯子的各类数减少, 不行.
两个最多: 这个可以, 因为多, 所以选了之后, 还有, 那么剩下的杯子种类尽可能多.
最多和最少: 这个也会导致种类减少.

所以, 应该选择两个最多的.

于是, 最直观的方法就是模拟以上过程.

但这种模拟的方法看起来, 太慢了, 想想有没有其它的方法.

看了一个官文的答案, 又全是先给出解, 再对解进行解释, 其实一点也没体现出是如何想出来的.
而自己以上的方法其实就很自然, 相信每一个人都可以想出来.

'''
class Solution:
    def fillCups(self, amount: List[int]) -> int:
        count = 0

        sort = sorted(amount, reverse=True)

        # 只要还有杯子
        while sort[0] != 0:
            if sort[1] != 0: # 至少有两种
                count += 1  
                sort[0] -= 1
                sort[1] -= 1

                sort = sorted(sort, reverse=True)
            else:
                count += sort[0]
                break
        
        return count


